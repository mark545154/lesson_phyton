###################################################################################
# - - - Манипуляции над данными с использованием библиотеки Pandas Визуализация данных
# с использованием библиотек Matplotlib и Seaborn - - - #

# Работа с дубликатами

import pandas as pd
df = pd.read_csv('duplicates.csv', delimiter=';')
# print(df.head())
# print(df.info())
print(len(df))  # len в pandas показывает кол-во строк
# print(df.duplicated())
df.drop_duplicates(inplace=True)  # Удаляем дубликаты!!!
# print(df.duplicated())


df.drop_duplicates(inplace=True, subset=['card_num'])  # Удаляем дубликаты по конкретному полю, где дубликатов не должно быть
# print(df['card_num'].duplicated())
df.reset_index(inplace=True)
print(len(df))  # len в pandas показывает кол-во строк

###################################################################################
#
# Задание
# 1. Похоже, что в процессе сбора данных некоторые строки могли быть записаны
# дважды. Используйте функцию .duplicated() в фрейме данных students, чтобы создать
# объект серии, называемый дубликатами.
# 2. Распечатайте значение .value_counts() серии дубликатов, чтобы узнать, сколько
# строк являются точными дубликатами.
# 3. Обновите значение "students", чтобы оно стало таблицей "students" с удалением
# дубликатов.
# 4. Снова используйте функцию .duplicated(), чтобы создать объект серии, называемый
# дубликатами, после удаления дубликатов. Распечатайте подсчеты значений еще раз.

import pandas as pd

df = pd.read_csv('students.csv', delimiter=';')
print(df.head())
print(df.info())

print(df.duplicated().sum())  # Смотрим какое кол-во дубликатов

df.drop_duplicates(inplace=True)  # Всегда используем inplace=True для просмотра дубликатов
print(df.duplicated().sum())  # Смотрим какое кол-во дубликатов
print(len(df))  # len в pandas показывает кол-во строк


# Задание
# 1. Выведите колонки students
# 2. Похоже, что столбец «gender_age» содержит и пол, и возраст!
# Выведите .head () столбца, чтобы увидеть, какие данные он содержит.
# 3. Похоже, что первый символ значений в поле gender_age содержит пол, а остальная
# часть строки содержит возраст. Давайте выделим гендерные данные в новый столбец
# под названием «gender».
# 4. Теперь выделите данные о возрасте в новый столбец под названием age.
# 5. Молодец! Давайте выведем .head () студентов, чтобы увидеть, как DataFrame будет
# выглядеть после создания нами новых столбцов.
# 6. Теперь нам больше не нужен столбец «gender _ age».
# Давайте установим DataFrame учащихся как DataFrame учащихся со всеми столбцами,
# кроме gender _ возраста.

# - - - - Разделение по индексу - - - - -#
df['age'] = df.gender_age.str[1:]  # Добавляем новый столбец с возрастом
df['gender'] = df.gender_age.str[0]  # Добавляем новый столбец с полом
df.drop(['gender_age'], inplace=True, axis=1)  # Удаляем столбец gender_age
print(df)

# - - - - Разделение по символам - - - - - #
# Мы больше не можем просто разделить по первым 4 символам, потому что admin и user
# имеют разную длину. Вместо этого мы знаем, что хотим разделить по «_». Используя это,
# мы можем разделить этот столбец на два отдельных, более чистых столбца:
# - - - - ПРИМЕР - - - - - - #
# # Create the 'str_split' column
# df['str_split'] = df.type.str.split('_')
# # Create the 'usertype' column
# df['usertype'] = df.str_split.str.get(0)
# # Create the 'country' column
# df['country'] = df.str_split.str.get(1)
##########################################
# Задание
# 1. Имена студентов хранятся в столбце full_name.
# Мы хотим разделить эти данные на два новых столбца, first_name и last_name.
# Во-первых, давайте создадим объект Series с именем name_split, который разделяет
# полное_имя на символ " ".
# 2. Теперь давайте создадим столбец с именем first_name, который принимает первый
# элемент в name_split.
# 3. Наконец, давайте создадим столбец с именем last_name, который принимает второй
# элемент в name_split.
# 4. Вывести head() таблицы students

df['str_split'] = df.full_name.str.split(' ')
df['first_name'] = df.str_split.str.get(0)
df['last_name'] = df.str_split.str.get(1)
df.drop(['str_split', 'full_name'], inplace=True, axis=1)
print(df)


# Задание
# 1. Давайте проверим типы в таблице студентов.
# Выведите атрибут.dtypes.
# 2. Если бы мы хотели построить диаграмму рассеяния возраста и среднего балла на
# экзамене, сможем ли мы сделать это с этим типом данных?
# Попробуйте распечатать среднее значение в столбце оценок учащихся.

print(df)
df['age'] = pd.to_numeric(df['age'])  # Переводим столбец age в числовое значение (цифры)
df['age'] = df['age'].apply('int64')  # Переводим столбец age в числовое значение (цифры)

# - - - - - - - - - - - - - !!!
# Внимание на типы !!!
# Каждый столбец DataFrame может содержать элементы одного и того же типа данных или
# dtype. Панды используют следующие типы dtypes: float, int, bool, datetime, timedelta, category
# и object. Часто мы хотим преобразовать типы, чтобы лучше анализировать. Если числовая
# категория, такая как «num_users», хранится как Серия объектов, а не как целые числа,
# например, это затрудняет выполнение чего-то вроде построения линейного графика
# пользователей с течением времени.
# Чтобы увидеть типы каждого столбца DataFrame, мы можем использовать:
# print(df.dtypes)
# item object
# price object
# calories int64
# dtype: object
# Мы видим, что dtype самого атрибута dtypes является объектом! Это объект Series, с
# которым вы уже работали. Объекты серии составляют все фреймы данных

print(df.dtypes)


# Задание
# 1. В последнем упражнении мы увидели, что найти среднее значение в столбце оценки
# сложно, когда данные хранятся как объекты, а не числа.
# Используйте регулярное выражение, чтобы убрать знаки% в столбце оценки.
# 2. Преобразуйте столбец оценки в числовой тип с помощью функции pd.to_numeric ()

# - - - - - - - ИЗБАВЛЯЕМСЯ ОТ ЗНАКА $ С ПОМОЩЬЮ РЕГУЛЯРНОГО ВЫРАЖЕНИЯ И ПЕРЕВОДИМ СТОЛБЕЦ В ЧИСЛО - - - - - #
# Мы видим, что столбец «цена» на самом деле состоит из строк, представляющих суммы в
# долларах. Этот столбец можно было бы гораздо лучше представить в виде чисел с
# плавающей запятой, чтобы мы могли взять среднее значение, вычислить другую
# совокупную статистику или сравнить разные фрукты друг с другом с точки зрения цены.
# Во-первых, мы можем использовать то, что мы знаем о регулярных выражениях, чтобы
# избавиться от всех знаков доллара:
# - - - - - - ПРИМЕР - - - - - #
# fruit.price = fruit['price'].replace('[\$,]', '', regex=True)
# Затем мы можем использовать функцию pandas .to_numeric () для преобразования строк,
# содержащих числовые значения, в целые числа или числа с плавающей запятой:
# fruit.price = pd.to_numeric(fruit.price)
##########################################

df['score'] = df['score'].replace('[\%]', '', regex=True)
df['score'] = pd.to_numeric(df['score'])  # Переводим столбец score в числовое значение (цифры)
print(df.dtypes)



# Задание
# 1. Выведите первые пять строк столбца оценок.
# 2. Каждое значение в классе выглядит как 9th grade”, “10th grade”, “11th grade”, “12th
# grade”.
# Мы хотим сократить это до числовой оценки. Возможно, мы хотим провести линейную
# регрессию по этим данным, для чего потребуются числовые входные данные.
# Используйте регулярное выражение, чтобы извлечь число из каждой строки в оценке и
# сохранить эти значения обратно в столбец оценки.
# 3. Выведите типы таблицы students.
# 4. Преобразуйте столбец оценок в числовые значения, а не в объекты.
# 5. Вычислите среднее значение оценки, сохраните его в переменной avg_grade и затем
# распечатайте!
# Мы не смогли бы этого сделать с такими строками, как 9th grade”, “10th grade”

split_df = df['grade'].str.split('(\d+)', expand=True)
print(split_df)
df['grade'] = pd.to_numeric(split_df[1])
print(df)


# Пропущенные значения
# У нас часто есть данные с отсутствующими элементами в результате проблемы с процессом
# сбора данных или ошибок в способе хранения данных. Отсутствующие элементы обычно
# отображаются как значения NaN (или Not a Number):
# Метод 1: удалить все строки с отсутствующим значением
# Для этого мы можем использовать .dropna ():

# - - - - - - Метод 1 С примером - - - - - - - #
# Метод 1: удалить все строки с отсутствующим значением
# Для этого мы можем использовать .dropna ():
# bill_df = bill_df.dropna()
# Эта команда приведет к созданию DataFrame без неполных строк:
# Если бы мы хотели удалить каждую строку со значением NaN только в столбце num_gests,
# мы могли бы указать подмножество:
# bill_df = bill_df.dropna(subset=['num_guests'])

# - - - - - - Метод 2 С примером - - - - - - - #
# Метод 2: заполните отсутствующие значения средним значением столбца или другим
# агрегированным значением.
# Для этого мы можем использовать .fillna ():
# bill_df = bill_df.fillna(value={"bill":bill_df.bill.mean(),
# "num_guests":bill_df.num_guests.mean()})
# Эта команда приведет к созданию DataFrame с соответствующим средним значением
# столбца вместо исходных NaN:

# Задание
# 1. Получите среднее значение в столбце оценки. Сохраните его в score_mean и
# выведите.
# 2. Предположим, что все, кто не набрал баллов за экзамен, его пропустили. Мы хотим
# заменить все nans значением 0. Давайте сделаем это со столбцом Score.
# Заполните все пропуски в ['score'] 0.
# 3. Снова получите среднее значение из столбца оценок. Сохраните его в score_mean_2
# и выведите.

print(df.isnull().sum())  # Смотрим кол-во пропусков в файле
df['score'] = df.score.fillna(0)
print(df.isnull().sum())
print(df)
df.to_csv('studens_clear.csv')
df.to_excel('studens_clear.xlsx')


# Метод 2: заполните отсутствующие значения средним значением столбца или другим
# агрегированным значением.
# Для этого мы можем использовать .fillna ():


###################################################################################
#
import numpy as np
import pandas as pd

df = pd.read_csv('ShoeFlywithPrice.csv', delimiter='\t')
most_exurance = df.price.max()
# print(df.head())
print(df[df['price'] == most_exurance])

num_colors = len(df.shoe_color.unique())  # Считаем сколько уникальных цветов в столбце
# print(df.shoe_color.unique())  # ['black' 'brown' 'navy' 'white' 'red']
# print(num_colors)  # Кол-во 5


# Расчет агрегатных функций II
# После использования groupby нам часто нужно очистить полученные данные.
# Как мы видели в предыдущем упражнении, функция groupby создает новую серию, а не
# DataFrame. В нашем примере ShoeFly.com индексами Серии были разные значения
# параметра shoe_type, а свойством name было price.
# Обычно мы предпочитаем, чтобы эти индексы были фактически столбцами. Для этого мы
# можем использовать reset_index (). Это преобразует нашу серию в DataFrame и переместит
# индексы в их собственный столбец.
# Как правило, вы всегда увидите оператор groupby, за которым следует reset_index

pricey_shoes = df.groupby('shoe_type').price.mean().reset_index()  # Считаем среднее значение по продажам в столбце shoe_type / Так же не забываем делать reset_index, чтобы можно было к ним обратиться

# print(pricey_shoes)


# Новый столбец содержит количество проданных сортов чая. У нас есть 3 черных чая, 4
# зеленых чая и так далее. Однако этот столбец называется id, потому что мы использовали
# столбец id чаев для подсчета количества. На самом деле мы хотим назвать этот столбец
# счетчиками. Помните, что мы можем переименовывать столбцы:

print(type(pricey_shoes))  # <class 'pandas.core.frame.DataFrame'>  / Если не сделаем reset_index то получится <class 'pandas.core.series.Series'>
# Не забываем делать reset_index!!!



# Расчет агрегатных функций III
# Иногда операция, которую вы хотите выполнить, сложнее среднего или подсчета. В этих
# случаях вы можете использовать метод apply и лямбда-функции, как мы это делали для
# операций с отдельными столбцами. Обратите внимание, что входными данными нашей
# лямбда-функции всегда будет список значений.
# Прекрасный пример этого - вычисление процентилей. Предположим, у нас есть DataFrame
# информации о сотрудниках с именем df, который имеет следующие столбцы:
# Задание
# 1. Еще раз вернемся к данным с ShoeFly.com. Наши специалисты по маркетингу
# говорят, что очень важно иметь доступную по доступной цене обувь для каждого цвета
# обуви, которую мы продаем.
# Давайте рассчитаем 25-й процентиль цены на обувь для каждого цвета shoe_color, чтобы
# помочь маркетингу решить, достаточно ли у нас дешевой обуви на распродаже. Сохраните
# данные в переменной cheap_shoes.
# Примечание: обязательно используйте reset_index () в конце вашего запроса, чтобы
# cheap_shoes был DataFrame

cheap_shoes = df.groupby('shoe_color').price.apply(lambda x: np.percentile(x, 25)).reset_index()  # Груперуем по цветам при помощи groupby по столбцу shoe_color
print(cheap_shoes)



###################################################################################
#

