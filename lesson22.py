###################################################################################
# - Работа с данными с использованием библиотеки NumPy Манипуляции над данными с использованием библиотеки Pandas - #
# Задание
# Ознакомьтесь с примером ниже
# Статистические распределения с NumPy
# Представьте, что вы работаете в приемной комиссии в университете. Часть вашей работы
# - собирать, анализировать и визуализировать данные, которые имеют отношение к
# заинтересованным кандидатам.
# Недавно вы заинтересовались, как гистограммы могут отображать различные
# распределения популяций и даже встречаемости. Вы думаете, что гистограммы были бы
# полезны для визуализации различных тенденций, таких как изменение количества
# отделений и участие во внеклассных занятиях. Вы также хотите узнать больше о том, как
# вы можете использовать случайно сгенерированные распределения для статистических
# расчетов и прогнозирования вероятности будущих событий, таких как успех вашей
# окончательной команды фрисби.
# В этом уроке мы будем использовать NumPy для вычисления распределений и Matplotlib
# для построения графиков наших вычислений.
# Один набор данных, который вы хотите проанализировать, — это зачисление на разные
# программы обучения. Посмотрев на гистограммы количества лет, в течение которых
# студенты обучаются по программе, вы можете определить, какие программы становятся
# более популярными, какие теряют популярность, а какие имеют устойчивый,
# непрерывный набор.
# Во-первых, давайте посмотрим, сколько сотен студентов решают поступить в университет
# и сколько лет они учатся.


# import numpy as np
# from matplotlib import pyplot as plt

# total_enrollment = [1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5]
#
# plt.hist(total_enrollment, bins=5, range=(1, 6))
# plt.title('Студенты обучающиеся (Код академии Университета)')
# plt.xlabel('Годы обучения')
# plt.ylabel('Студенты Уровень (Рост)')
# # plt.show()

# Гистограмма выше показывает общее количество учащихся университета, которое
# довольно стабильно. Это равномерное распределение, и это то, что хочет видеть
# университет. Общее количество учащихся остается на хорошем уровне.
# Теперь давайте посмотрим на набор специально для студентов, желающих получить
# степень по истории

# history_enrollment = [1, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5]
# plt.hist(history_enrollment, bins=5, range=(1, 6))
# plt.title('Студенты обучающиеся (Код академии Университета)')
# plt.xlabel('Годы обучения')
# plt.ylabel('Студенты Уровень (Уровень роста)')
# # plt.show()


# О чем говорит нам эта гистограмма? Что ж, это несколько искаженный левый набор данных,
# мы видим, что намного больше студентов, которые обучались на 3 или 4 года за 1 и 2 года.
# Это говорит о том, что программа «История» становится все менее популярной. Куда же
# тогда собираются все студенты?
# Школа недавно вложила много денег в новое здание факультета компьютерных наук.
# Давайте посмотрим на набор и посмотрим, окупаются ли вложения.

# cs_enrollment = [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 4]
# plt.hist(history_enrollment, bins=5, range=(1, 6))
# plt.title('Студенты обучающиеся (Код академии Университета)')
# plt.xlabel('Годы обучения')
# plt.ylabel('Студенты Уровень (Уровень роста)')
# # plt.show()


# Похоже, что за последние годы количество студентов на факультете компьютерных наук
# резко возросло. Это могло быть связано с тем, что университет вложил средства в отдел,
# или это могло быть признаком того, что востребованные профессиональные навыки в
# реальном мире меняются. Какой бы ни была причина, гистограммы позволяют четко видеть
# тенденции.
# Заинтересованные абитуриенты хотели бы знать, какие результаты SAT имеют принятые
# студенты. Ранее вы подсчитали, что средний балл составляет 1250 со стандартным
# отклонением 50.
# Вместо того, чтобы собирать оценки каждого учащегося, вы берете то, что знаете о данных,
# и используете генератор случайных чисел для создания модели.

# sat_scores = np.random.normal(1250, 50, size=100000)
# plt.hist(sat_scores, bins=1000, range=(800, 1600))
# plt.title('Результаты тестов принятых студентов')
# plt.xlabel('Результат в баллах')
# plt.ylabel('Студентов')
# # plt.show()


# Одна из главных составляющих вашей школы - это ваша превосходная команда фрисби.
# Команда выигрывает около 70% из 50 игр за сезон, или 35 игр. Заинтересованный кандидат
# хочет знать, каковы шансы, что он сможет улучшить свой рекорд до 40 игр. Вы используете
# то, что знаете о биномиальных распределениях, чтобы вычислить вероятность такого
# появления

# ultimate = np.random.binomial(50, 0.70, size=10000)
# plt.hist(ultimate, bins=50, range=(0, 50), density=True)
# plt.xlabel('Число игр')
# plt.ylabel('Частота')
# plt.show()
# # Поскольку это немного сложно увидеть на графике, давайте точно посчитаем, какой у них
# # шанс выиграть 40 игр:
# print(np.mean(ultimate == 40))  # 0.0356

###################################################################################
# Гистограммы, часть I
# Когда мы впервые смотрим на набор данных, мы хотим быстро понять некоторые вещи о
# нем:
# • Встречаются ли одни ценности чаще, чем другие?
# • Каков диапазон набора данных (т. Е. Минимальное и максимальное значения)?
# • Много выбросов?
# Мы можем визуализировать эту информацию с помощью диаграммы, называемой
# гистограммой.
# Например, предположим, что у нас есть следующий набор данных

# import numpy as np
# from matplotlib import pyplot as plt
#
# d = [1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5]
# plt.hist(d, bins=5)
# plt.title('Гистограмма')
# plt.xlabel('Номер по x')
# plt.ylabel('Номер по y')
# plt.show()


###################################################################################
# Задание
# 1. Посмотрите на гистограмму справа. Сколько значений в наборе данных равно 5 или
# 6?
# Сохраните сумму в значение переменной sum

# import numpy as np
# from matplotlib import pyplot as plt

# summ = np.array([1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 4, 5])
# plt.hist(summ, bins=5, range=(1, 6))
# plt.title('Гистограмма')
# plt.xlabel('Номер по x')
# plt.ylabel('Номер по y')
# plt.show()

###################################################################################
# Задание
# 1. Мы включили набор данных, который содержит информацию о времени в пути (в
# минутах, округленных до ближайшего целого числа) в системе метро Нью-Йорка.
# Начните с импорта matplotlib.
# 2. Отобразите гистограмму с помощью plt.show ().
# 3. Теперь предположим, что мы хотели увеличить масштаб и посмотреть, сколько
# людей ездят на работу от 20 до 50 минут.
# Измените команду гистограммы, чтобы получить гистограмму с диапазоном от 20
# до 50.
# 4. Измените гистограмму еще раз, чтобы на ней было 6 интервалов.

# import numpy as np
# from matplotlib import pyplot as plt
#
# commutes = np.array([20, 30, 50, 40, 24, 26, 27, 27, 30, 50, 20, 34, 15, 18, 17, 35, 37, 38, 43, 45, 47])
#
# plt.hist(commutes, range=(20, 51), bins=6)
#
# plt.show()


###################################################################################
# Задание
# 1. Наш друг - палеонтолог. Он изучает два типа динозавров: брахиозавр и фикозавр.
# Он говорит нам, что:
# Брахиозавр имеет бедренную кость (бедренную кость) со средней длиной 6,7 футов и
# стандартным отклонением 0,7 фута.
# У фикозавров есть бедренные кости (бедренная кость) со средней длиной 7,7 футов и
# стандартным отклонением 0,3 фута.
# Мы хотели бы знать, как выглядят эти распределения.
# Используйте np.random.normal, чтобы заполнить b_data (брахиозавр) и f_data
# (fictionosaurus) случайно сгенерированными выборками с правильным средним значением
# и стандартным отклонением. В каждом наборе данных должно быть 1000 выборок.
# Код, который мы предоставили ниже, будет отображать распределения для вас
# 2. Наш друг обнаружил бедренную кость неопознанного динозавра на его последних
# раскопках. Бедренная кость 6,6 футов в длину.
# Ваш друг почти уверен, что бедренная кость принадлежит либо брахиозавру, либо
# фикционозавру. Глядя на графические данные, определите, какому динозавру, скорее всего,
# принадлежит этот скелет, и сохраните свой ответ в переменной mystery_dino.
# 3. Наш друг обнаружил еще одну бедренную кость. Это бедро составляет 7,5 футов в
# длину. Очевидно, 7,5 футов ближе к среднему значению для фикозавра (7,7 футов),
# чем к среднему значению для брахиозавра (6,5 футов).
# Можем ли мы быть абсолютно уверены в том, что бедренная кость принадлежит
# фикционозавру? Сохраните свой ответ (True или False), чтобы ответить.
# Как гистограммы помогают вам объяснить свой ответ

# import numpy as np
# from matplotlib import pyplot as plt
#
# # Брахиозавр
# b_data = np.random.normal(6.7, 0.7, size=1000)
#
# # Фикозавр
# f_data = np.random.normal(7.7, 0.3, size=1000)
#
# plt.hist(b_data, bins=30, range=(5, 8.5), histtype='step', label='Брахиозавр')
# plt.hist(f_data, bins=30, range=(5, 8.5), histtype='step', label='Фикозавр')
# plt.xlabel('Длина бедренной кости (ft)')
# plt.ylabel('Какое то значение по y')
# plt.legend(loc=2)
# plt.show()
#
# print(np.mean(b_data >= 6.7))
# print(np.mean(f_data >= 7.7))

###################################################################################
# Задание
# 1. Средний балл за SAT составляет 1000, а стандартное отклонение - 100.
# Вычислите сумму, которая будет на одно стандартное отклонение выше среднего, и сохраните ее в
# переменной one_above.
# 2. Вычислите сумму, которая будет на одно стандартное отклонение ниже среднего, и сохраните
# ее в переменной one_below.
# 3. Вывести в консоль значения one_above и one_below.
# 4. Экзамен сдали 2000 студентов. Сколько результатов будут лежать в диапазоне от one_above до
# one_below?
# Сохраните свой ответ в переменной one_std и распечатайте его в терминале.

# mean_score = 1000
# st_dev = 100
# one_above = mean_score + st_dev
# one_below = mean_score - st_dev
#
# one_std = 2000 * 0.68
# print(one_std)


###################################################################################
# Биномиальное распределение, часть I
# Известно, что некий баскетболист выполняет 30% штрафных бросков. В матче в пятницу вечером
# у него была возможность выполнить 10 штрафных бросков. Сколько штрафных бросков вы
# можете ожидать от него? Мы ожидаем 0,30 * 10 = 3.
# Однако на самом деле он сделал 4 штрафных броска из 10 или 40%. Это удивительно? Означает ли
# это, что он на самом деле его навыки лучше, чем мы думали?
# Биномиальное распределение может нам помочь. Он говорит нам, насколько вероятно достижение
# определенного количества «успехов» с учетом вероятности успеха и количества испытаний.
# В этом примере:
# • Вероятность успеха 30% (он выполняет 30% штрафных бросков).
# • Количество попыток - 10 (сделал 10 выстрелов).
# • Количество успехов - 4 (сделал 4 выстрела).
# Биномиальное распределение важно, потому что оно позволяет нам узнать, насколько вероятен
# определенный результат, даже если он не является ожидаемым. Из этого графика видно, что для
# нашего баскетболиста не так уж и маловероятно, что он получит 4 штрафных броска из 10. Однако
# для него маловероятно, что он получит все 10.
# Есть несколько сложных формул для определения этих типов вероятностей. К счастью для нас, мы
# можем использовать NumPy - в частности, его способность генерировать случайные числа. Мы
# можем использовать эти случайные числа для моделирования распределения числовых данных,
# которое соответствует реальному сценарию, который мы хотим понять.
# Например, предположим, что мы хотим знать разные вероятности того, что наш баскетболист
# сделает 1, 2, 3 и т. д. Из 10 бросков.
# В NumPy есть функция для генерации биномиальных распределений: np.random.binomial, которую
# мы можем использовать для определения вероятности различных результатов.
# Функция вернет количество успехов для каждого «эксперимента».
# Требуются следующие аргументы:
# • N: количество образцов или испытаний.
# • P: вероятность успеха
# • size: количество экспериментов
# Проведем серию «экспериментов» нашего баскетболиста, сделавшего 10 бросков. Мы выбираем
# большое N, чтобы быть уверенным, что наши вероятности сходятся в правильном ответе.
# Теперь у нас есть рекорд в 10 000 экспериментов. Мы можем использовать Matplotlib для
# построения результатов всех этих экспериментов:

# import numpy as np
# from matplotlib import pyplot as plt
#
# a = np.random.binomial(10, 0.30, size=10000)
#
# plt.hist(a, range=(0, 10), bins=10, density=True)
# plt.xlabel('Количество "Штрафных бросков"')
# plt.ylabel('Частота')
# plt.show()
#
# print(np.mean(a == 4))  # вероятность из массива

###################################################################################
# Задание
# 1. Человек отправляет 500 писем с просьбой о пожертвовании на их дело, с оценочной
# вероятностью, что 25 человек (5%) откроют письмо и нажмут, чтобы сделать
# пожертвование. Было проведено 10 000 экспериментов.
# Используя формулу биномиального распределения, рассчитайте распределение и сохраните его в
# переменной email.
# 2. Постройте график биномиального распределения с использованием настроек гистограммы
# по умолчанию и отобразите его с помощью plt.show ().

# import numpy as np
# from matplotlib import pyplot as plt
#
# a = np.random.binomial(500, 0.05, size=10000)
#
# plt.hist(a, bins=20, range=(10, 100), density=True)
# plt.xlabel('Ось x')
# plt.ylabel('Ось y')
# plt.show()
#
# print(np.mean(a == 10))  # Вероятность открытия письма


###################################################################################
# Задание
# 1. Вернемся к нашему примеру с электронной почтой. Помните, что мы отправили 500 писем,
# с расчетной вероятностью, что их откроют 25 человек. Было 10 000 испытаний.
# Какова вероятность, что никто не откроет письмо? Сохраните результаты в переменной no_emails.
# 2. Вы недавно наняли нового сотрудника по маркетингу, который хочет провести A / Bтестирование
# для оценки эффективности электронных писем, чтобы узнать, как реагируют
# люди. Какова вероятность, что 8% или более людей откроют письмо? Сохраните результаты
# в переменной b_test_emails.
# 3. Выведите результаты в консоль

# import numpy as np
# from matplotlib import pyplot as plt
#
# a = np.random.binomial(500, 0.05, size=10000)
#
# plt.hist(a, bins=20, range=(10, 100), density=True)
# plt.xlabel('Ось x')
# plt.ylabel('Ось y')
# plt.show()
#
# print(np.mean(a == 0.08 * 500))  # Вероятность открытия письма

###################################################################################
# Задание
# 1. Представьте, что вы работаете в ботаническом саду и хотите посмотреть, как выглядят
# подсолнухи, которые вы посадили в прошлом году, чтобы увидеть, хотите ли вы посадить
# их больше.
# Вычислите среднее значение и стандартное отклонение этого набора данных. Сохраните среднее
# значение в sunflowers_mean и стандартное отклонение в sunflowers_std. Набор данных загрузите в
# переменную sunflowers из CSVна основании данных:
# 2. Постройте гистограмму по нашим данным, используя код:
# 3. Из гистограммы видно, что наши данные не распределяются нормально. Давайте создадим
# нормально распределенную выборку для сравнения с тем, что мы наблюдали.
# Создайте 5000 случайных выборок с таким же средним и стандартным отклонением, как у
# подсолнухов. Сохраните их в sunflowers_normal.
# 4. Построить график нормального распределения, используя код:
# 5. Как правило, 10% посаженных подсолнухов не цветут. Мы посадили 200 и хотим
# знать вероятность того, что менее 20 не зацветут.
# Сначала сгенерируйте 5000 биномиальных случайных чисел, которые представляют нашу
# ситуацию. Сохраните их в experiments.
# 6. В каком проценте экспериментов не зацвело менее 20 подсолнухов?
# Сохраните свой ответ в переменной prob. Это приблизительная вероятность того, что
# менее 20 наших подсолнухов не зацветут.
# 7. Выведите prob. Возможно ли, что менее 20 наших подсолнухов не зацветут

# import numpy as np
# from matplotlib import pyplot as plt
#
# sunfowers = np.genfromtxt('sunflowers.csv', delimiter=';')
# print(sunfowers)
# plt.hist(sunfowers, range=(11, 15), histtype='step', linewidth=2, label='observed', density=True)
# plt.legend()
# plt.show()
#
# sun_mean = np.mean(sunfowers)
# st_dev = np.std(sunfowers)
#
# sunfowers_normal = np.random.normal(sun_mean, st_dev, size=5000)
# plt.hist(sunfowers_normal, range=(11, 15), histtype='step', linewidth=2, label='normal', density=True)
# plt.legend()
# plt.show()
#
# experiments = np.random.binomial(200, 0.1, size=5000)
#
# prob = np.mean(experiments < 20)
# print(prob)  # 0.4634


# ##################################################################################
#  Crunchie Вы работаете в
# маркетинге в пищевой компании YummyCorps, которая разрабатывает новый вид вкусных и полезных злаков под названием
# CrunchieMunchies. Вы хотите продемонстрировать потребителям, насколько полезны ваши хлопья по сравнению с другими
# ведущими брендами, поэтому вы откопали данные о питании нескольких разных конкурентов. Ваша задача - использовать
# статистические вычисления NumPy, чтобы проанализировать эти данные и доказать, что ваши хлопья CrunchieMunchies -
# самый полезный выбор для потребителей.
#
# 1.	Импортируйте библиотеку NumPy
# 2.	Просмотрите файл cereal.csv. Этот файл содержит сообщенные количества
# калорий для различных марок злаков. Загрузите данные из файла и сохраните их как calorie_stats. (Создайте файл
# самостоятельно на основе данных ниже)
# 3.	В одной порции CrunchieMunchies 60 калорий. Насколько выше среднее количество калорий у ваших конкурентов?
#
# Сохраните ответ в переменной average_calories и выведите переменную в консоль, чтобы увидеть ответ.
#
# 4.	Достаточно ли адекватно среднее количество калорий отражает распределение набора данных? Давайте отсортируем
# данные и посмотрим.
#
# Отсортируйте данные и сохраните результат в переменной calorie_stats_sorted. Выведите отсортированные данные в
# консоль.
#
# 5.	Вы видите то, что вижу я? Похоже, что большинство злаков выше среднего. Посмотрим, лучше ли медиана отражает
# набор данных.
#
# Вычислите медиану набора данных и сохраните свой ответ в median_calories. Выведите медиану, чтобы увидеть,
# как она соотносится со средним. 6.	Хотя медиана оказывает, что по крайней мере половина наших значений превышает
# 100 калорий, было бы более впечатляющим показать, что значительная часть участников соревнований имеет более
# высокое количество калорий, чем CrunchieMunchies.
#
# Вычислите различные процентили и распечатайте их на терминале, пока не найдете самый низкий процентиль, превышающий
# 60 калорий. Сохраните это значение в переменной nth_percentile.
#
# 7.	Хотя процентиль показывает нам, что у большинства конкурентов гораздо более высокое количество калорий,
# использовать эту концепцию в маркетинговых материалах неудобно.
#
# Вместо этого давайте посчитаем процент хлопьев, содержащих более 60 калорий на порцию. Сохраните свой ответ в
# переменной more_calories и выведите его в консоль.
#
# 8.	Вау! Это действительно высокий процент. Это будет очень полезно при продвижении CrunchieMunchies. Но возникает
# вопрос: насколько вариативны данные в наборе? Можем ли мы сделать обобщение, что большинство злаков содержат около
# 100 калорий или разброс еще больше?
#
# Рассчитайте величину отклонения, определив стандартное отклонение. Сохраните свой ответ в calorie_std и выведите в
# консоль. Что нам дает значение стандартного отклонения в нашем анализе?
#
# 9.	Напишите короткий абзац, в котором резюмируйте свои выводы и то, как, по вашему мнению, эти данные могут быть
# использованы в интересах Yummy Corp при маркетинге CrunchieMunchies.

import numpy as np
from matplotlib import pyplot as plt

calorie_stats = np.genfromtxt('cereal.csv', delimiter=',')
# print(calorie_stats)

average_calories = np.mean(calorie_stats)
print('У конкурентов выше среднее кол-во калорий: ', average_calories)

###################################################################################
#

