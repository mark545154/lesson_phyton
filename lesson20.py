###################################################################################
# - - - - - - - - - - - Работа с данными с использованием библиотеки NumPy - - - -#
# NumPy имеет множество применений, в том числе:
# • Эффективная работа с большим количеством номеров одновременно
# • Генерация случайных чисел
# • Выполнение множества различных числовых функций (например,
# вычисление sin, cos, tan, mean, median и т. Д.)
# В следующих упражнениях мы узнаем, как создавать одномерные и двумерные
# массивы и выполнять основные операции с массивами.

# import numpy as np
#
# my_list = [1, 2, 3, 4, 5, 6]
# my_array = np.array(my_list)
# print(my_array)

###################################################################################
# Задание
# 1. Представьте, что вы учитель и вам нужно следить за результатами тестов своего
# ученика. По первому тесту ученики получили следующие баллы:
# 92, 94, 88, 91, 87
# Создайте массив NumPy с этими значениями и сохраните его под именем test_1.

# import numpy as np
#
# test_1 = np.array([92, 94, 88, 91, 87])
#
# print(test_1)

###################################################################################
# Создание массива из CSV
# Как правило, данные непосредственно в массив не вводятся. Вместо этого вы будете
# импортировать данные откуда-то еще.
# Мы можем преобразовывать файлы CSV (значения, разделенные запятыми) в массивы с
# помощью функции np.genfromtxt ():
# Рассмотрим следующий CSV-файл sample.csv

# import numpy as np
#
# test2 = np.genfromtxt('sample.csv', delimiter=',')
# print(type(test2))

###################################################################################
# Операции с массивами NumPy
# Как правило, массивы NumPy более эффективны, чем списки. Одна из причин
# заключается в том, что они позволяют выполнять поэлементные операции. Поэлементная
# операция позволяет быстро выполнять операцию, например сложение, над каждым
# элементом массива.

# import numpy as np
#
# my_list = [1, 2, 3, 4, 5]
#
# my_list3 = [item + 3 for item in my_list]
#
# print(my_list3)
#
# my_array = np.array(my_list)
# # my_array3 = my_array + 3
# # my_array3 = my_array ** 2  # Возводим в степень
# # my_array3 = np.sqrt(my_array)  # Корень квадратный из числа
# my_array3 = np.sqrt(my_array[0])  # Корень квадратный из числа к первому числу
#
# print(my_array3)

###################################################################################
# Задание
# 1. Оценки учащегося по третьему тесту хранятся в массиве test_3.
# Но оказывается, что в одном из вопросов третьего теста была ошибка. Дайте каждому
# студенту два дополнительных балла и сохраните новый массив в test_3_fixed

# import numpy as np
#
# test_3 = np.array([87, 85, 72, 90, 92])
# test_3_fixed = test_3 + 2
#
# print(test_3_fixed)


###################################################################################
# Операции с массивами NumPy II
# Массивы также могут быть добавлены или вычтены друг из друга в NumPy, при условии,
# что массивы имеют одинаковое количество элементов.
# При добавлении или вычитании массивов в NumPy каждый элемент будет добавлен /
# вычтен к соответствующему элементу.

# import numpy as np
#
# my_list1 = np.array([1, 2, 3, 4])
# my_list2 = np.array([1, 2, 3, 4])
#
# my_list3 = my_list1 + my_list2  # Складывает только одинаковые по длине массивы
#
# print(my_list3)

###################################################################################
# Задание
# 1. Давайте найдем среднее значение результатов тестов каждого учащегося, чтобы
# рассчитать их итоговую оценку за семестр. Начните с добавления трех массивов и
# сохраните ответ в переменной total_grade. Не забудьте использовать измененные
# баллы для третьего теста.
# 2. Теперь разделите total_grade на количество пройденных тестов, чтобы найти
# средний балл для каждого ученика. Сохраните ответ в переменной final_grade.
# 3. Выведите результат в консоль

# import numpy as np
#
# test_1 = np.array([92, 94, 88, 91, 87])
# test_2 = np.array([79, 100, 86, 93, 91])
# test_3 = np.array([87, 85, 72, 90, 92])
#
# total_grade = test_1 + test_2 + test_3
# print(total_grade)
#
# final_grade = total_grade / 3
# print(final_grade)


###################################################################################
# Двумерные массивы
# В Python мы можем создавать списки, состоящие из других списков. Точно так же в NumPy
# мы можем создать массив массивов. Если все массивы, составляющие наш больший массив,
# имеют одинаковый размер, то у него есть специальное имя: двумерный массив.
# В предыдущих упражнениях мы хранили результаты тестов студентов в отдельных
# одномерных массивах для каждого теста:


# import numpy as np
#
# test_1 = np.array([92, 94, 88, 91, 87])
# test_2 = np.array([79, 100, 86, 93, 91])
# test_3 = np.array([87, 85, 72, 90, 92])
#
# # Но мы могли бы также сохранить все эти данные в одном двумерном массиве
# np.array([[92, 94, 88, 91, 87],
#           [79, 100, 86, 93, 91],
#           [87, 85, 72, 90, 92]])


###################################################################################
# Задание
# 1. В статистике мы часто используем двумерные массивы для представления набора
# выборок. Например, если мы подбрасываем монету, мы можем представить каждую
# орел как 1, а каждый решка как 0.
# Создайте одномерный массив для эксперимента с подбрасыванием монеты, который
# приводит к получению орлов, решек, решек, орлов, решек, и сохраните его в переменной
# coin_toss.
# 2. Мы снова запускаем эксперимент и получаем следующий результат: решка, решка,
# орел, орел, орел. Создайте новый массив, который представляет оба результата как
# один эксперимент. Сохраните новый массив в coin_toss_again

# import numpy as np
#
# coin_toss = [1, 0, 0, 1, 0]
# coin_toss2 = [0, 0, 1, 1, 1]
#
# coin_toss_again = np.array([coin_toss, coin_toss2])
# print(coin_toss_again)

###################################################################################
# Выбор элементов из одномерного массива
# NumPy позволяет нам выбирать элементы из массива, используя их индексы. Рассмотрим
# одномерный массив

# import numpy as np
#
# test_1 = np.array([92, 94, 88, 91, 87])
#
# # print(test_1[2:-1])
#
# coin_toss_again = np.array([[1, 0, 0, 1, 0],
#                             [0, 0, 1, 1, 1]])
#
# print(coin_toss_again[0:2, 2:4])

###################################################################################
# Задание
# 1. Вернемся к результатам тестов наших учеников. В следующей таблице показаны
# все три массива тестов, выровненные по именам учащихся

# import numpy as np
#
# tests = np.array([[92, 94, 88, 91, 87],
#                   [79, 100, 86, 93, 91],
#                   [87, 85, 72, 90, 92]])
#
# jeremy_test_2 = tests[1, 3]  # 93
# print(jeremy_test_2)
#
# manual_adwoa_test_1 = tests[0, 1:3]
# print(manual_adwoa_test_1)
#
# cody_test3 = tests[2, -1]
# print(cody_test3)
#
# tanya_test2 = tests[1, 0]
# print(tanya_test2)
#
# test_test = tests[0:, -3:]
# print(test_test)

###################################################################################
# Логические операции с массивами
# Еще одна полезная вещь, которую могут делать массивы, — это выполнять поэлементные
# логические операции. Например, предположим, что мы хотим знать, сколько элементов в
# массиве больше 5. Мы можем легко написать код, который проверяет наличие значения
# True для каждого элемента в массиве, без использования цикла for:

# import numpy as np
#
# a = np.array([10, 2, 2, 4, 5, 3, 9, 8, 9, 7])
# b = a[(a > 5) & (a < 10)]  # [9 8 9 7]
# print(b)
#
# # print(a[a > 5])  # [10  9  8  9  7]
# # print(a > 5)  # [ True False False False False False  True  True  True  True]

###################################################################################
# Задание
# 1. Сегодня мы посещаем Goldilocks Porridge Festival, пробуем различные хлопья для
# завтрака и оцениваем их по температуре (указывается в градусах Фаренгейта).
# Создайте логическое условие, которое выбирает образцы в массиве овсянки меньше 60 и
# сохраняет их в переменной с именем cold.
# 2. Создайте логическое условие, которое находит все значения, превышающие 80, и
# сохраняет их в переменной с именем hot.
# 3. Создайте логическое условие, которое находит все значения в диапазоне от 60 до 80
# (включительно) и сохраняет их в переменной с именем just_right.
# 4. Выведите в консоль каждый массив

# import numpy as np
#
# porridge = np.array([79, 65, 50, 63, 56, 90, 85, 98, 79, 51])
# cold = porridge[porridge < 60]
# print(cold)
# hot = porridge[porridge > 80]
# print(hot)
# just_right = porridge[(porridge > 60) & (porridge < 80)]
# print(just_right)

###################################################################################
# Задание
# 1. Вы работаете в группе ученых-климатологов, и одна из ваших ролей - принимать
# еженедельные данные о температуре и вводить их в массивы NumPy для
# последующего анализа. Датчик регистрирует температуру 4 раза в день в 0:00, 6:00,
# 12:00 и 18:00. Вам предоставляются данные за последние недели (с понедельника по
# пятницу) и вас просят создать массив NumPy.
# Начните с импорта пакета numpy.
# 2. Создайте массив температур, импортировав данные в CSV-файл temperature_data.csv
# (CSV на основе данных Национального управления океанических и атмосферных
# исследований). CSV содержит данные:
# 3. Проверьте данные, выведя их в терминал.
# Столбцы — это время, начиная с 0:00, а строки - это дни, начиная с понедельника, а
# значения представляют собой зарегистрированные температуры в это время в эти дни.
# 4. Один из исследователей заметил, что датчик был неправильно обнулен, и все
# зарегистрированные температуры были на 3,0 градуса ниже нуля.
# Исправьте массив так, чтобы показания температуры были точными, и сохраните их в
# Temperature_fixed.
# 5. Другой исследователь спросил у вас значения температуры понедельника.
# Сохраните их в новом массиве monday_temperas.
# 6. «Хммм, интересно, - бормочет исследователь, - можешь также дать мне данные за
# 6:00 утра по четвергам и пятницам?»
# Сохраните эти данные в новом массиве thursday_friday_morning.
# 7. Наконец, настойчивый исследователь теперь хочет, чтобы в течение недели были
# все высокие и низкие температуры.
# Выберите все температуры ниже 50 или выше 60 градусов и сохраните их в новом
# массиве temperature_extremes

# import numpy as np
#
# temp = np.genfromtxt('temperature_data.csv', delimiter=',')
# # print(temp)
# temperature_fixed = temp+3
# # print(temperature_fixed)
# monday_temperas = temperature_fixed[0]
# # print(monday_temperas)
# # thursday_friday_morning = temperature_fixed[3:, 1]  # [44.1 43.9]
# thursday_friday_morning = temperature_fixed[-2:, 1]  # [44.1 43.9] тоже самое
# # print(thursday_friday_morning)
# temperature_extremes = temperature_fixed[(temperature_fixed < 50) | (temperature_fixed > 60)]
# print(temperature_extremes)  # [46.6 48.1 61.8 47.  61.3 49.7 47.2 60.9 49.5 47.1 60.6 49.2 46.9 60.2]

###################################################################################
# Пекарня Бетти
# Бетти всегда использовала книгу рецептов своей бабушки, чтобы делать печенье,
# пирожные, блины и хлеб для своих друзей и семьи. Она готовится открыть бизнес, и ей
# нужно будет начать закупать молоко, яйца, сахар, муку и масло оптом.
# Помогите Бетти выяснить, сколько ей нужно купить, используя массивы NumPy,
# описывающие ее рецепты.
# Задания
# 1. Начните с импорта NumPy как np.
# 2. Все рецепты Бетти требуют молока, яиц, сахара, муки и масла. Например, ее
# рецепт кекса требует:
# Мука Сахар Яйца Молоко Масло
# 2 стакана 0,75 стакана 2 яйца 1 стакан 0,5 стакана
# Создайте массив NumPy, представляющий эти данные. Каждый элемент должен быть
# числом (например, 2 для «2 чашек»). Сохраните этот массив как кексы.
# 3. Помощник Бетти скомпилировал все ее рецепты в файл csv (переменные,
# разделенные запятыми) под названием recipes.csv (создайте файл самостоятельно
# на основании данных). Загрузите этот файл в переменную recipes.

import numpy as np

recipes = np.genfromtxt('recipes.csv', delimiter=',')
# print(recipes)
eggs = recipes[0:, 2]
# print(eggs)  # [2. 1. 1. 2.]

# print(eggs == 1)  # [False  True  True False]

cakes = recipes[0]
# print(cakes)
cookie = recipes[2]
# print(cookie)
double_batch = cakes * 2
# print(double_batch)
grocery_list = cookie + double_batch
print(grocery_list)


###################################################################################
#

###################################################################################
#
