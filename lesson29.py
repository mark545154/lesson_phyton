###################################################################################
# - - - - Визуализация данных с использованием библиотек Matplotlib и Seaborn - - - #
# Загрузить данные из Файла Nedvig
# Предварительное исследование данных
# Встроенные функции Pandas и Matplotlib
# 1. Средствами встроенных функций Pandas получить описательную статистику
# (максимум, минимум, среднее, стандартное отклонение) по переменной Цена
# (используем метод max(), min(), mean(), std()).
# 2. Построить точечный график для цены (х – номер): выброс.
# 3. Построить точечный график для цены в зависимости от числа комнат, определить,
# какой квартире соответствует выброс.
# 4. Построить точечный график для цены в зависимости от общей площади.
# 5. Сделать выводы в отношении качества и характеристик данных.
# 6. Определить интервалы задания гистограммы, построить гистограмму для
# переменной Цена.
# 7. Удалить данные с выбросами по цене. Получить описательную статистику
# (максимум, минимум, среднее, стандартное отклонение с использованием метода
# describe()) по переменной Цена, построить гистограмму.
# 8. Построить нормальное распределение. Графически сравнить полученные
# распределения (гистограмму цены без выбросов).
# 9. Сделать вывод в отношении нормальности распределения цен на квартиры

# import pandas as pd
# import numpy as np
# from matplotlib import pyplot as plt
#
# df = pd.read_csv('Nedvig.csv', delimiter=';', encoding='cp1251')
# print(df['Цена, тыс. руб.'].max())
# print(df['Цена, тыс. руб.'].min())
# print(df['Цена, тыс. руб.'].mean())
# print(df['Цена, тыс. руб.'].std())
# sigma = df['Цена, тыс. руб.'].std()
#
# plt.scatter(df.Номер, df['Цена, тыс. руб.'])  # Смотрим выброс
# plt.show()
# plt.scatter(df['Число комнат'], df['Цена, тыс. руб.'])  # scatter - диаграмма рассеивания или точечный график
# plt.show()
# plt.scatter(df['Общая'], df['Цена, тыс. руб.'])
# plt.show()
#
# # plt.hist(df['Цена, тыс. руб.'], bins=50)  # Гистограмма
# # plt.show()
#
# df.sort_values(by=['Цена, тыс. руб.'], inplace=True, ascending=False)  # Сортируем данные перед удалением нужной строки. ascending - говорит о возрастании, но так как указано False значит убыванию.
# df.reset_index(inplace=True, drop=True)  #Сортируем индексы по порядку, т.к. они перемешались
# print(df)
#
# df_clear = df[(df['Цена, тыс. руб.'] > df['Цена, тыс. руб.'].mean() - 3 * sigma) & (df['Цена, тыс. руб.'] < df['Цена, тыс. руб.'].mean() + 3 * sigma)]  # Удаляем выброс из нашего файла, чтобы нормализовать файл
# # df_clear = df[df['Цена, тыс. руб.']<df['Цена, тыс. руб.'].mean()+5*df['Цена, тыс. руб.'].std()]
# print(df_clear['Цена, тыс. руб.'].describe())  # Считаем и выводим все нужные нам данные
#
# plt.hist(df_clear['Цена, тыс. руб.'], bins=50)  # Гистограмма нового графика df_clear
# plt.show()
#
# norm_rasp = np.random.normal(df_clear['Цена, тыс. руб.'].mean(), df_clear['Цена, тыс. руб.'].std(), size=1500)
# plt.hist(norm_rasp, bins=50)  # Гистограмма нового графика df_clear
# plt.show()
#
# print(df.info())


###################################################################################
# Анализ профиля пациента клиники
# Дана выгрузка пациентов стоматологической клиники. Необходимо провести анализ
# для выявления профиля типичного пациента и вывести отчет о результатах в
# текстовый файл, графики сохранить в файлы jpeg.
# На выходе необходимо получить:
# 1. График распределения по полу (круговая диаграмма).
# 2. График распределения всех пациентов по возрастам.
# 3. Подумать верно ли проводить анализ по всем возрастам
# 4. Взять для анализа только взрослое население и создать График зависимости
# затрат от возраста (диаграмма рассеивания (.scatter()).
# 5. Определите типичный возраст взрослого пациента и стандартное отклонение.
# 6. Проделать то же самое для детей
# 7. Выделить отдельный датафрейм первичных пациентов за последние 2 месяца
# 8. Рассчитайте средний чек за визит в клинике
# 9. Не забывайте оформлять подписи осей, заголовки и легенду графиков
# Настройте расстояния на графиках в одной фигуре для улучшения
# отображения.
# Полученные графики вывести как изображения.
# Для выполнения данной работы ниже прописан пошаговый алгоритм.
# Постарайтесь сначала выполнить работу самостоятельно
# 1. Импорт бибилиотек pandas и matplotlib
# 2. Чтение данных из файла в Датафрейм
# 3. Необходимо проверить данные на полные дубликаты и вывести из количество
# (value_counts() или sum())
# 4. При наличии дубликатов, удалить их и проверить снова.
# 5. Подумайте какое поле может однозначно идентифицировать объекты,
# описываемые в датафрейме. Проверьте данные на наличие дубликатов по
# этому полю (полям) и, при необходимости, удалите их.
# 6. Исходя из поставленной задачи, нам необходимо получить уникальные
# значения поля Пол и проверить его бинарность. (.unique()). При
# необходимости, удалите строки с отсутствующими значениями в этом поле.
# 7. Проверьте типы данных в датафрейме. При необходимости, измените
# числовые данные в числовой тип (pd.to_numeric())
# 8. Вычислите возраст пациентов по их дате рождения в отдельный столбец. Для
# того, чтобы получить сегодняшнюю дату в pandas есть метод
# pd.Timestamp('now').Обратите внимание, что столбец birth в настоящее время
# является строками. Сначала преобразуйте их в Timestamps используя
# pd.to_datetime (обращение к столбцу). Вы можете вычесть birth от now, чтобы
# получить разницу timedelta64. Чтобы преобразовать это в годы, используйте
# метод astype('<m8[Y]') или astype('timedelta64[Y]')
# 9. Наши данные готовы к обработке. Для начала отобразите гистограмму
# распределения всех пациентов по возрастам
# 10. Судя по графику, в клиники довольно большую долю занимают дети до 5 лет.
# 11. Выведите диаграмму рассеивания (точечная диаграмма .scatter()) оплаченных
# сумм по возрастам. Мы видим, что основная доля оплат на большие чеки
# концентрируется в более зрелом возрасте.
# 12. Давайте возьмем для анализа только взрослое население и построим такие же
# диаграммы. Создайте новый датафрейм с записями пациентов от 18 лет.
# 13. Рассчитайте медиану и стандартное отклонение, чтобы оценить диапазон
# разброса среднего возраста типичного пациента.
# 14. Сохраните пациентов младшего возраста в отдельный датафрейм и
# рассчитайте среднюю, медиану и стандартное отклонение для этого возраста.
# 15. Выделить отдельный датафрейм первичных пациентов за последние 2 месяца.
# Постройте графики по нему.
# 16. Для расчета среднего чека необхоимо учитывать количество визитов и суммы
# затрат пациента. При необходимости можно создать новый вычисляемый
# столбец (сумма/визиты), по которому выводится средняя.
# Оформите Вывод данных в виде отчета о пациентах в текстовый файл.
# Сохраните диаграммы как изображения. Не забудьте оформить легенды,
# заголовки, подписи осей

import pandas as pd
from matplotlib import pyplot as plt

df = pd.read_csv('Пациенты_new.csv', delimiter=';', encoding='cp1251')

print(df)
print(df.info())
df = df.drop_duplicates()  # Удаляем дубликаты
# print(df.duplicated(subset=['last_name', 'first_name', 'third_name']).sum())  # Смотрим дубликаты по Имени и Фамилии, а так же году рождения
print(df.duplicated(subset='card_num').value_counts())  # Смотрим по номеру карты пациента
df.dropna(subset=['gender', 'birth'], inplace=True)  # Делаем уникальные значения gender ['Муж' 'Жен']
print(df.info())

print(df.gender.unique())

df['birth'] = pd.to_datetime(df.birth, dayfirst=True)
df['last_visit'] = pd.to_datetime(df.last_visit, dayfirst=True)
df['age'] = (pd.Timestamp('now') - df.birth).astype('m8[Y]')
df = df[df.age < 100]
df = df[df.sales_cost < 1000000]

print(df.head())

plt.hist(df.age, bins=50)
plt.show()
plt.hist(df.gender, bins=50)
plt.show()

df_young = df[df.age < 18]
df_adult = df[df.age >= 18]

plt.scatter(df_young.age, df_young.sales_cost)
plt.show()
plt.scatter(df_adult.age, df_adult.sales_cost)
plt.show()

plt.hist(df_young.age, bins=10)
plt.show()
plt.hist(df_adult.age, bins=10)
plt.show()

print(df.age.mean())
print(df.age.std())

print(df_adult.age.median())
print(df_adult.age.mean())
print(df_adult.age.std())

print(df_young.age.median())
print(df_young.age.mean())
print(df_young.age.std())

df_new = df[(df.visits_num < 2) & (df.last_visit > pd.to_datetime('01.05.2022', dayfirst=True))]
print(df_new)

df_adult['aver'] = df_adult.sales_cost / df_adult.visits_num

print(df_adult.aver.mean())



###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#


###################################################################################
#
