####################################################################
# - - - - - - - - Работа с файлами - - - - - - - - - #
# Итерации по строкам
# Когда мы читаем файл, мы можем захотеть получить весь документ в одной строке,
# например, как при методе .read (). Но что, если бы мы хотели сохранить каждую строку в
# переменной? Мы можем использовать функцию .readlines () для чтения текстового файла
# построчно, вместо того, чтобы считывать сразу целиком. Допустим, у нас есть файл:

with open('keats_sonnet.txt') as keats_sonnet:
    content = keats_sonnet.read()
    for line in keats_sonnet.readlines():
        print(line)  # Выводит файл с отступами меж строк
print(content)  # Выводит файл без отступов


####################################################################
# Чтение строки
# Иногда вам не нужно перебирать весь файл. Для этого есть другой файловый метод
# .readline (), который будет читать только одну строку за раз. Если весь документ будет
# прочитан таким образом построчно, последующие вызовы .readline () не вызовут ошибки,
# но начнут возвращать пустую строку (""). Предположим, у нас есть такой файл:

# readline() Выводит строки по очередно. Сколько раз вызовите, столько строк и выдаст! В данном файле 4 строки


with open('keats_sonnet.txt', 'r') as keats_sonnet:  # 'r' есть по умолчанию, для чтения и его можно не указывать!
    content = keats_sonnet.readline()
    print(content)  # Выводит одну строку с файла
    content = keats_sonnet.readline()
    print(content)  # Выводит вторую строку с файла
    content = keats_sonnet.readline()
    print(content)  # Выводит третью строку с файла
    content = keats_sonnet.readline()
    print(content)  # Выводит четвёртую строку с файла


####################################################################
# Добавление к файлу
# Так что, возможно, вас беспокоит полное удаление и перезапись существующих файлов.
# Разве нельзя просто добавить строку в файл, не удаляя его полностью? Конечно, есть!
# Вместо того, чтобы открывать файл с помощью аргумента «w» для режима записи, мы
# открываем его с помощью «a» для режима добавления. Если у нас есть сгенерированный
# файл со следующим содержимым:

# encoding='utf-8' меняем кодировку если вылазиют каракули!
# 'w' Стирает данные и записывает новые данные в существующем файле
# Создаём и открываем файл для записи
with open('new_file.txt', 'w', encoding='utf-8') as nf:  # 'w' Быть аккуратным! При изменении, перезаписывает данные
    # в созданном файле!!!
    nf.write('Привет медвед')


# 'a' Добавляет данные в файл
with open('new_file.txt', 'a', encoding='utf-8') as nf:  # 'a' Добавляем данные в файл. Добавляет в конец!
    nf.write('Привет мир!')


# - - - - - - - - - (\n) чтобы записать с новой строки!!!
# 'a' Добавляет данные в файл и указываем (\n) чтобы записать с новой строки!!!
with open('new_file.txt', 'a', encoding='utf-8') as nf:  # 'a' Добавляем данные в файл. Добавляет в конец!
    nf.write('\n Привет мир! И все его жители!')


# Выводим данные с файла в консоль!!
with open('new_file.txt', 'r', encoding='utf-8') as nf:
    cont = nf.read()
    print(cont)

# Обязательно нужно закрывать файл после окончания с ним работы!!! close() позволяет это сделать
nf.close()

nf = open('fun_cities.txt', 'a')  # Открываем файл на запись и + создаёт его!
nf.write("Montréal")  # Записываем значение в новый, открытый файл
nf.close()  # После операций указанных выше закрываем файл

####################################################################
# Почему так сложно закрыть файл? Что ж, большинство других аспектов нашего кода
# связаны с тем, что контролирует сам Python. Все создаваемые вами переменные: целые
# числа, списки, словари - все это объекты Python, и Python знает, как их очистить, когда с
# ними будет работать. Поскольку ваши файлы существуют вне вашего скрипта Python, нам
# нужно сообщить Python, когда мы закончили с ними, чтобы он мог закрыть соединение с
# этим файлом. Если оставить соединение с файлом открытым без необходимости, это может
# повлиять на производительность или повлиять на другие программы на вашем компьютере,
# которые могут пытаться получить доступ к этому файлу.
# Синтаксис with заменяет старые способы доступа к файлам, когда вам нужно вручную
# вызывать .close () для объекта файла. Мы все еще можем открыть файл и добавить к нему
# старый синтаксис, если не забыть закрыть соединение с файлом после этого

fun_cities_file = open('fun_cities1.txt', 'a')  # Открываем файл на запись и + создаёт его
# Теперь после записи и открытия можем добавить строку в файл fun_cities.txt
fun_cities_file.write("Montréal футбольный клуб!")
# Обязательно после открытия и записи в файл нужно ЗАКРЫТЬ его!
fun_cities_file.close()

####################################################################
# Что такое файл CSV?
# Текстовые файлы - не единственное, что может читать Python, но это единственное, что нам
# не нужна дополнительная библиотека синтаксического анализа для понимания. Файлы CSV
# — это пример текстового файла, который накладывает структуру на свои данные. CSV
# означает значения, разделенные запятыми, а файлы CSV обычно используются для
# экспорта данных из программного обеспечения для работы с электронными таблицами
# (например, Microsoft Excel или Google Sheets) в переносимый формат. Таблица, которая
# выглядит следующим образом
# В файле CSV те же самые данные будут отображаться следующим образом:

import csv

# Мы передаем дополнительный аргумент ключевого слова newline = '' в функцию открытия
# файла open (), чтобы случайно не принять разрыв строки в одном из наших полей данных
# за новую строку в нашем CSV (подробнее об этом читайте в Python документация).

list_of_email_addresses = []
with open('users.csv', newline='') as users_csv:
    # После открытия нашего нового файла CSV мы используем csv.DictReader (users_csv),
    # который преобразует строки нашего файла CSV в словари Python, для которых мы можем
    # использовать методы доступа. Ключи словаря по умолчанию - это записи в первой строке
    # нашего CSV-файла. Поскольку первая строка нашего CSV вызывает третье поле в нашем
    # CSV «Электронная почта», мы можем использовать это как ключ в каждой строке нашего
    # DictReader
    user_reader = csv.DictReader(users_csv)
    # Когда мы перебираем строки нашего объекта user_reader, мы получаем доступ ко всем
    # строкам в нашем CSV как к словарям (за исключением первой строки, которую мы
    # использовали для маркировки ключей нашего словаря). Получив доступ к ключу
    # «Электронная почта» в каждой из этих строк, мы можем получить адрес электронной почты
    # в этой строке и добавить его в наш list_of_email_addresses.
    for row in user_reader:
        list_of_email_addresses.append(row['Email'])

        # print(list(user_reader))
        print(row)
# print(list_of_email_addresses)  # Выводим только эл. почты все

####################################################################
# Чтение различных типов файлов CSV
# Мы действовали так, как будто файлы CSV — это файлы со значениями, разделенными
# запятыми. Это правда, что CSV означает это, но также верно и то, что в наши дни
# допустимы другие способы разделения значений.
# Раньше люди называли файлы значений, разделенных табуляцией, файлами TSV, но по
# мере роста популярности других разделителей все осознали, что создание нового формата
# файла. [A-z] sv для каждого используемого символа-разделителя не является устойчивым.
# Поэтому мы вызываем все файлы со списком различных значений в CSV-файл, а затем
# используем разные разделители (например, запятую или табуляцию), чтобы указать, где
# начинаются и заканчиваются различные значения (разделение значений).
# Допустим, у нас была адресная книга. Поскольку в адресах обычно используются запятые,
# нам потребуется использовать другой разделитель для нашей информации. Поскольку ни в
# одной из наших данных нет точек с запятой (;), мы можем их использовать.
# Обратите внимание на символ \ n, это escape-последовательность для новой строки.
# Возможность экранирования новой строки в наших данных символом \ n является причиной
# того, что мы передаем аргумент ключевого слова newline = '' функции open ().
# Также обратите внимание, что во многих из этих адресов есть запятые! Ничего страшного,
# мы все равно сможем это прочитать. Если бы мы хотели, скажем, распечатать все адреса в
# этом CSV-файле, мы могли бы сделать следующее:

import csv

with open('addresses.csv', newline='') as adr_csv:
    adr_reader = csv.DictReader(adr_csv, delimiter=';')
    for row in adr_reader:
        print(row['Address'])

####################################################################
# Написание файла CSV
# Естественно, если у нас есть возможность читать различные файлы CSV, мы можем
# захотеть иметь возможность программно создавать файлы CSV, которые сохраняют
# выходные данные и данные, которые кто-то может загрузить в свое программное
# обеспечение для работы с электронными таблицами. Допустим, у нас есть большой список
# данных, которые мы хотим сохранить в файл CSV. Мы могли сделать следующее:

import csv

big_list = [{'name': 'Fredrick Stein', 'userid': 6712359021, 'is_admin': False},
            {'name': 'Wiltmore Denis', 'userid': 2525942, 'is_admin': False},
            {'name': 'Greely Plonk', 'userid': 15890235, 'is_admin': False},
            {'name': 'Dendris Stulo', 'userid': 572189563, 'is_admin': True}]

with open('output.csv', 'w') as output_csv:
    fields = ['name', 'userid', 'is_admin']
    output_writer = csv.DictWriter(output_csv, fieldnames=fields)
    output_writer.writeheader()

    for row in big_list:
        output_writer.writerow(row)

####################################################################
# Чтение файла JSON
# CSV - не единственный формат файлов, для которого Python имеет встроенную библиотеку.
# Мы также можем использовать файловые инструменты Python для чтения и записи JSON.
# JSON, сокращение от JavaScript Object Notation, представляет собой формат файла,
# вдохновленный языком программирования JavaScript.
# Формат JSON поразительно похож на синтаксис словаря Python, поэтому файлы JSON
# могут быть легко читаемыми с точки зрения разработчика Python. Тем не менее, Python
# поставляется с пакетом json, который поможет нам преобразовать файлы JSON в реальные
# словари Python. Предположим, у нас есть файл JSON, подобный следующему:

import json

with open('purchase_14781239.json') as purchase_json:
    purchase_data = json.load(purchase_json)

print(purchase_data['user'])

####################################################################
# Запись файла JSON
# Естественно, мы также можем использовать библиотеку json для перевода объектов Python
# в JSON. Это особенно полезно в тех случаях, когда вы используете библиотеку Python для
# обслуживания веб-страниц, вы также сможете обслуживать JSON. Допустим, у нас есть
# словарь Python, который мы хотели сохранить в виде файла JSON

import json

turn_to_json = {
    'eventId': 674189,
    'dateTime': '2015-02-12T09:23:17.511Z',
    'chocolate': 'Semi-sweet Dark',
    'isTomatoAFruit': True
}
# Мы сможем создать файл JSON с этой информацией, выполнив следующие действия:

# Мы импортируем модуль json, открываем файл режима записи под переменной json_file, а
# затем используем метод json.dump () для записи в файл. json.dump () принимает два
# аргумента: сначала объект данных, затем объект файла, который вы хотите сохранить
with open('output.json', 'w') as js:
    json.dump(turn_to_json, js)

####################################################################
# Упражнение 1.
# Вспомним упражнение с Дмитрием. Напомним ее содержание:
# Я работаю в компании, обслуживающей проблемы информационной безопасности на
# других предприятиях. К нам обратился директор маленькой рекламной компании.
# Основная проблема в том, что у них есть охранник Дмитрий, который устанавливает
# компьютерные игры на АРМ (автоматизированные рабочие места) сотрудников, когда тех
# нет на работе по долгу (находятся в отпуске) и играет всеми ночами напролет. Поэтому вас
# просят разработать приложение, которое проверяло введенные учетные и разграничивало
# права сотрудников. Для охранника Дмитрия просят сделать специализированное
# уведомление: «Дмитрий, твое рабочее место находится в другой комнате. Отойди от чужого
# компьютера и займись работой!». 1. Введем переменную «user_name» 2. Далее введем
# переменную, которая выводит текст для Дмитрия. Назовем ее Dmitriy_check 3. Введем
# переменную, которая хранит сообщение для других сотрудников, вошедших в систему:
# «Добро пожаловать» 4. Напишем оператор if, которые проверяет значение переменной
# user_name 5. Вывести в консоль результат выполнения программы для user_name=
# «Дмитрий» и для user_name= «Ангелина».
# Усовершенствовать программу, загружая логин и пароль из файла csv

import csv

def file_loading(file_name, delim, column):
    result = []
    with open(file_name) as file_csv:
        file_reader = csv.DictReader(file_csv, delimiter=delim)
        for row in file_reader:
            result.append(row[column])
    return result

def user_check(user_name, arm, user_list, arm_list):
    for index in range(len(user_list)):
        if user_name not in user_list:
            return 'НЕ верный логин!'
        elif user_name != 'dmitriy' and user_name == user_list[index]:
            if arm == arm_list[index]:
                return 'Добро пожаловать!'
            else:
                return 'Неверный логин!'
        elif user_name == 'dmitriy' and user_name == user_list[index]:
            if arm == arm_list[index]:
                return 'Добро пожаловать!'
            else:
                return 'Дмитрий, твое рабочее место находится в другой комнате. Отойди от чужого компьютера и займись ' \
                       'работой!'

# users = file_loading('logins.csv', ';', 'user')
# arms = file_loading('logins.csv', ';', 'arm')

# print(users, arms)

# print(user_check(input('Введите логин: '), input('введите arm: '), users, arms))  # Первый вариант вывода!
print(user_check(input('Введите логин: '),
                 input('введите arm: '),
                 file_loading('logins.csv', ';', 'user'),
                 file_loading('logins.csv', ';', 'arm')))  # Второй вариант вывода!

####################################################################
#

